[
  {
    "tip": "JavaScript provides two ways to test equality.\n==\n===\nThe Double Equals converts the variable values to the same type before performing the comparison (Type Coercion).\nThe Triple equals doesn't type coerce and returns true only if both values and types are identical. ",
    "level": 1
  },
  {
    "tip": "Did you know, an assignment to an undeclared variable automatically results in a global variable being created. Remember to always use var, let or const.\n\nAlthough global variables may seem harmless as a beginner, they can result in some nasty, unexpected side effects!",
    "level": 1
  },
  {
    "tip": "Work with arrays often? Then use 'splice' instead of 'delete' to delete an item from an array. Using 'delete' replaces the item with undefined instead of the removing it from the array.",
    "level": 1
  },
  {
    "tip": "Using a switch/case is faster when there are more than 2 cases. Avoid using switch cases when you have more than 10 cases.\nAlso remember to always end switch statements with a default case. Even if you think there's no need. This is good practise and makes your code robust.",
    "level": 1
  },
  {
    "tip": "Can you invoke functions before declaration? Yes. Hoisting is a JavaScript mechanism in which variable and function declaration are moved to the top of the file. Thus allowing you to invoke function or reference variables before they have been declared. Try it out!",
    "level": 1
  },
  {
    "tip": "Know what a pure function is? A pure function can be defined as a function that produces no side effects, nor does it rely on side effects and is independent of state. A pure function, when called with the same argument, will always produce the same result.",
    "level": 2
  },

  {
    "tip": "The 'eval' function gives us access to JavaScript's compiler.\nEssentially, we can execute a string's result by passing it as a parameter of 'eval'.\nThis decreases performance and poses a huge security risk because it grants far too much power to the passed in text. Avoid!",
    "level": 2
  },
  {
    "tip": "Handy tip - Always place JS scripts at the bottom of the page. - This gives the HTML time to load before any JavaScript loads, which can prevent errors and speed up the website response time.",
    "level": 1
  },
  {
    "tip": "The Array.from() static method creates a new, shallow-copied Array instance from a string, array-like or iterable object.\n\nExample:\nconsole.log(Array.from('codivate'));\n// [\"c\", \"o\", \"d\", \"i\", \"v\", \"a\", \"t\", \"e\"]"
  },
  {
    "tip": "Handy tip - Always place JS scripts at the bottom of the page. - This gives the HTML time to load before any JavaScript loads, which can prevent errors and speed up the website response time.",
    "level": 2
  },
  {
    "tip": "Need a function to run automatically when a page loads or a parents functions is called. JavaScripts provides you with self-executing functions. Simply wrap your function in parenthesis, and then append an additional set, which essentially calls the function.",
    "level": 2
  },
  {
    "tip": "Handy Tip - Always treat numbers and booleans as primitive values and not objects. Declaring these types as objects, slows down execution speed, and produces nasty side effects!",
    "level": 1
  },
  {
    "tip": "What happens if a function is called with a missing argument?\nThe value of the missing argument is set to undefined. To avoid this, JS allows you to assign default values to arguments./n/n If you call a function with too many arguments, the extra arguments are simply ignored.",
    "level": 1
  },
  {
    "tip": "What happens if a function is called with a missing argument?\nThe value of the missing argument is set to undefined. To avoid this, JS allows you to assign default values to arguments./n/n If you call a function with too many arguments, the extra arguments are simply ignored.",
    "level": 2
  },
  {
    "tip": "Declarations on top - It's good coding practice to put all your declarations at the top of your file or function. Here's why: Cleaner code, provide a single place to look for local variables, reduce the possibility of unwanted re-declarations.",
    "level": 1
  },
  {
    "tip": "Template literals make working with strings so much easier. To create a template literal simply use a backtick (`) instead of a single/double quote.\nTemplate literals also provide an easy way to interpolate variables and expressions into strings by simply using the ${...} syntax.",
    "level": 1
  },
  {
    "tip": "To bypass JS’s leniency you can opt into using strict mode by adding the line ‘use strict’ either at the top of your file (for the whole section) or before the desired function.\n\nBy using strict mode silent errors that would’ve previously been ok now throw errors.",
    "level": 2
  },
  {
    "tip": "Inheritance allows you to share properties and methods between classes. Use the ‘super’ keyword to access and call functions on an object's parent. In doing so, you enhance the readability and reusable of your code by only defining methods once (in the parent class).",
    "level": 2
  },
  {
    "tip": "The rest parameter syntax allows you to represent an indefinite number of arguments as an array.\nA function's last or only parameter can be prefixed with ... which will cause all remaining (user supplied) arguments to be placed within a 'standard' JavaScript array. Try it out!",
    "level": 2
  },
  {
    "tip": "Know what closure is? Closure is the combination of a function bundled together with references to its lexical environment. Put simply, a closure gives you access to an outer functions scope from an inner function.  In JS, closures are created every time a function is created.",
    "level": 3
  },
  {
    "tip": "One of the  biggest benefits of ‘Closures’ is that they allows us to privatise variables, much like Java. We can achieve this privatisation by using factory functions (A factory function is any function which is not a class or constructor that returns a new object).",
    "level": 3
  },
  {
    "tip": "When dealing with functions that can accept a large number of optional arguments. Instead of passing the large number of arguments in, which could complicate the function, you can pass just one argument which ends up being a collection of arguments declared in an object literal.",
    "level": 3
  },
  {
    "tip": "Accessing the DOM is slow. If you are going to read the content of an element numerous times, it's better to bind it in a local variable. Keep in mind, if you later remove the value of the DOM, the variable should be set to 'null', so it doesn’t cause any memory leaks.",
    "level": 3
  },
  {
    "tip": "It’s unlikely that all functions are needed for the initial load of a page. If an action must be performed for a function to be executed (e.g. clicking an element), it’s possible to defer loading that function until after the initial page load. This speeds up the page load time.",
    "level": 3
  },
  {
    "tip": "console.time and console.timeEnd methods allow devs to time any routine and get a duration back in milliseconds.  Since JavaScript performance is becoming increasingly important, it's useful to know basic techniques for benchmarking routines.",
    "level": 3
  },
  {
    "tip": "The rest parameter syntax allows you to represent an indefinite number of arguments as an array.\nA function's last or only parameter can be prefixed with ... which will cause all remaining (user supplied) arguments to be placed within a 'standard' JavaScript array. Try it out!",
    "level": 3
  },
  {
    "tip": "When you clone an object in JavaScript, you can either create a deep copy or a shallow copy.\nThe difference is that a deep copy, like Lodash's cloneDeep() function, recursively clones all nested objects.\n Whereas shallow cloning does not.",
    "level": 3
  }
]
